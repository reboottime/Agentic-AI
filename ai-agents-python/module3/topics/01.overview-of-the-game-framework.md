# Overview of the GAME Framework

## Agent Loop Fundamentals

The agent loop executes until the task is solved:

1. Agent decides next action
2. Action is executed in an environment
3. Results are stored in memory
4. Loop continues

## GAME Framework Components

Four key abstractions that compose an agent:

### Goals

- Instructions describing what the agent is trying to achieve
- Include process instructions and other guidance
- Can be changed to modify agent behavior

### Actions

- Set of capabilities the agent can use to achieve goals
- Examples: get calendar availability, create meeting invite, draft email
- Remain consistent across different environments

### Memory

- Stores results of past actions
- Allows agent to remember what happened
- Enables continuity across loop iterations

### Environment

- Where actions are executed and feedback is obtained
- Can be different systems (Google, Office 365, Python process, cloud APIs)
- Same agent can be plugged into different environments

## Framework Benefits

### Reusability

- Same agent with identical goals/actions/memory can work in different environments
- Example: Calendar agent works with both Google Calendar/Gmail and Outlook/Office 365

### Flexibility

- Goals can be modified while keeping same actions and memory
- Example 1: Auto-schedule meetings immediately
- Example 2: Check availability and inform user of options

### Environment Independence

- Core agent logic separated from environment-specific implementation
- Actions like "get availability" implemented differently per environment

## Design Approach

- Use GAME components as basic abstractions for agent design
- Prototype quickly in conversations with tools like ChatGPT or Claude
- Experiment with different tool naming and configurations
- Test effects through interactive conversations
