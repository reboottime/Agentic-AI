When we're thinking about agents, it's helpful to take a step back and think about what are the fundamental things that are happening in the agent loop and can we abstract this out into something that we can use to help us think about and design agents and also to design our code around. So I wanna go back to this agent loop. So we have basically a loop that is executing until the task is solved. So we go and we execute our agent and then when we're done, we get back some output out here. Now, what are the key things that we are doing in this loop? Well, at each step, we're deciding what we're going to do. So we're letting the agent go and decide the next action. Basically, we're constructing a prompt, we're having to decide the next action. How does it decide the next action? Well, we give it some goals or instructions describing what it's trying to achieve. So it looks at its goals and then it tries to decide the next action to take. We then go and execute that action and we get some result back and what do we do with that action? Well, we put it into a memory and then we go and loop back around. Now, when we execute the action, where are we executing this action? Well, we're executing it in some type of environment. This environment could be just the process that we're running in. It could be some Python code that we're running. It could be some action we're taking in a cloud. It could be some API call in some third-party system. And so there's different environments where it could be executing actions and then we're giving it the result of actions and storing it as a memory. But the core idea of this loop stays the same. So if we start thinking about what we're talking about, we can begin building a framework. When we build an agent, we're gonna have a set of goals or instructions that it's following. We're gonna have a set of actions that it can take to achieve those goals. So in general, we're gonna go and configure an agent by giving it a set of goals or instructions. We're gonna give it a set of actions that it can take in order to try to achieve those goals. We're gonna give it memory so that it can see the results of past actions and know what happened and remember what it did. And then the last thing we're gonna do is we're gonna give it an environment to execute those actions in. So if we think about this, these things basically compose an agent. So if we have some AI agent, we have a set of goals that it's trying to achieve. And in with the goals, I sort of loosely use the term goals. It's gonna have instructions about process and other things. It's gonna have the actions that it can take to try to achieve those goals. The next thing it's going to have is memory so that as we execute the loop, it remembers what happened. And it's gonna have some environment that it can execute actions in and get feedback on them. So we're not gonna typically be, we're gonna have many different sort of environments that we may be able to plug this in. We may even be able to build the agent in a reusable fashion. So we have the different goals, actions, and memory. And the actions are things like get my availability on my calendar, create a meeting invite, create a draft email. And then we may have different environments where we plug that agent in. For example, it might be running in a Google environment where it's a Google calendar in Gmail. Or we may then take that same agent and plug it into an environment where it's Office 365. And now it's an Outlook calendar. And we're dealing with Outlook email. And so the goals and actions and memory, the set of sort of tools that we're given it are the same things like get my availability, create event, and create a draft email. With those don't change, but how we implement them and execute them in the environment changes. And so we can change the environment. Similarly, we can have some set of actions and memory that we're doing like we want to be able to do things with a calendar. So we have like check availability, draft email, but we change our goals. And so for one agent, we say, if you get a request to schedule a meeting, you just immediately create the invite and you directly send out the email. Another one we have may have a different goal. We want to say you check the availability and then you email the user. The goal is to inform the user of their options, not to automatically schedule it for them. The goals change. So these sort of four things, if we start using them as basic abstractions for thinking about the design of agents, but also thinking about a framework for implementing in code to design agents, it can be really helpful. The other thing I want to encourage you about when you're thinking about agents, just think about prototyping quickly in conversations. Go and try things out. See what the effect of different tool namings and things are by playing around in an interactive conversation with some tool like ChatGBT or Cloud.