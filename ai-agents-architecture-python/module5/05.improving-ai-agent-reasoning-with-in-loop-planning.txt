Now we've seen how ahead-of-time planning can help us, but let's think about what's happening with the ahead-of-time planning. We go and we generate our initial plan that we're gonna follow at the beginning, and then our agent goes and runs, but it's agent loop that happens, that gets created and runs, happens after the plan creation, and then when we're done, we exit. Now, the problem is this, is if we go and we loop a whole bunch of times with the agent, what happens is, is that if we're just putting our plan in memory, is our plan may end up way back here in memory, and we go and we have a ton of stuff that's happening later on afterwards. So the problem with that is that our plan can not be, it might end up not being top of mind anymore. So if we go and we have a short plan, right, and we plan up front, and it has a few steps to take, that memory will end up pretty close to the front. So let's say it ends up right here, and then there's some additional steps that take place. But if we have a loop that runs a really long time, that memory could end up way back here at the start, and we may have some really long loop that it then is going through, and that memory may end up way back at the beginning. Now, there's all kinds of ways that we could programmatically go and reinsert the plan, and just make sure it always can see the plan, and that's an easy thing to do. But sometimes, if the plan particularly is really complex and long, and it's taking many, many different steps to get there, the agent may not immediately track where it is in the plan. It may go and repeat steps, or do things it shouldn't, or go off on a tangent. And so sometimes, it's helpful to go and basically remind the agent where it is in the plan. So the idea behind this is we go and we can create a plan up front. We then can go begin executing our agent loop that we're gonna execute until we're ready and done. But at the end of every loop, we basically go and we create, essentially, you can think of it as a progress report. Where are we in the plan? So the progress report is basically going to tell us what the plan is, so we remind ourselves what the plan is, what's done, and we reflect on and think step-by-step of what steps have been completed, and then what's next. And the idea behind this is that every time we run the loop, we have the LLM stop and think about what are you trying to do, what have you completed already, and what's next. Now, this isn't guaranteed to solve all of our long-running chain problems. In fact, it's not gonna solve all of them. But often, it can be a simple, effective technique that can help us if we're going into sort of these longer loops to go and reinforce what's taken place. And what we do is we have it go and execute the loop, look at the original plan, think step-by-step about what has gotten done and what needs to be done next, and then we bring that plan into the next loop iteration so that now it has a better idea of what the next step is. And so what we can see is that sometimes this will help generate sort of consistency across these longer-running loops. Now, do we need this? Do we need this every single loop iteration? Potentially not. And so one of the things we can also do is we can generate it and do it when we need it. For example, every third iteration, every fifth iteration. And again, this is something you would want to experiment with. And all of these things are things you're gonna want to experiment with, but you would go and check and see, like if we give it a plan up front, how many steps can we typically run in our plan before it starts going off course or becoming too inconsistent for us? And then we can begin thinking about, okay, well, let's have it update its progress. We can either do it every iteration of the loop or we can have it do it every other iteration of the loop. And the idea behind this is we're trying to keep our progress up to date. We're trying to basically keep it looking at and understanding in the chain of actions and execution so that it is always up to date with what's happening. Because it's easier to say, well, here is the current plan state. Here's the next action. Now put out the next plan state that has the thing. So like to go one step. It's usually easier to figure out what the next step is, assuming that it's logical. Now, if you have plans and things where it goes down a path and then it turns out that was a dead end that it needs to adapt, this isn't probably going to work. This may not get you anything. But for particular things, we have lots of steps and it can be helpful to be able to make it so it's just like always thinking of and evaluating what is the next step? What have I completed? Sometimes this can be very helpful.