One of the things we've seen is that agents tend to work best when we give them a specialized set of tools and a really specialized set of instructions. The more specific the agent is to the task that it's working on, typically the better it's going to perform and the more consistent and predictable it's going to be. So this brings up a question. How do we go and conquer challenges where we really need to have a broad set of reasoning capabilities? We need to do more than just schedule one meeting. We also need to think about project management or some complex set of tasks. And they aren't just clean individual things that we can put into one agent. We're going to have to have an agent that goes and deals with all of it. Well, this is where multi-agent systems come in. And so the idea behind this is typically we will have some coordinator agent or some process or application that kicks this off and we'll have some agent that goes off and its job is to sort of maintain the overall sort of thread of execution. So its goal is basically you can think of it as the project manager to go and delegate to other agents. Now there's many different ways to do this, but let's start off with this simple idea. So what this agent will do is it will go and at different points in the task that it's trying to accomplish, it will delegate to another agent. So let's think of like scheduling a meeting. At some point in the task, the agent may go and call out to another agent, which is our scheduler agent, and then it will wait for it to schedule the meeting and it will come back, let's say, with the time. And maybe it has a list of participants because maybe it had to decide who was available for the meeting. And then the agent might go off and it might talk to another one that can generate a meeting agenda. And then it will get back the meeting agenda from that other agent. And it can go and call through to a bunch of agents. Now the key thing behind this is that any time we go and build a new agent, the thing that's focused on scheduling can have very specific sort of logic and system instructions that tell it how to think about meetings and how to think about scheduling. And what makes sense and should be paid attention to when you're scheduling may be very different from when you're trying to come up with a creative meeting agenda. Or maybe you want to have something that builds meeting agendas for something very specific. You want it to go and do something related to quarterly reports and meeting agendas related to quarterly reports. And quarterly reports and the meeting agendas for those have to have all these very specific things and all this complex logic about who goes and how and how you structure the meeting. But the idea is that we don't want to have one big set of system instructions for this whole thing here that just has all the different rules in it because then it becomes sort of polluting of the individual agent. Like how is this thing going to go and figure out how to coordinate when it's got all this stuff related to meeting agendas and scheduling. And what we see is often things that may make sense in one context can pollute another context if they're all one big system instruction or set of system instructions. So what we want to do is we want to have nice, clean, sort of isolated system instructions. And the easiest way to do that is to have separate agents to go and perform each individual type of task. And the other ability of this is rather than having let's say one agent, let's say this one has a calendar tool and it can create an invite tool. We have this one that knows how to self-prompt for an agenda. So it has a limited set of stuff right here. It can go and basically do a prompt and it knows a very specific format for that prompt. And then this one over here knows how to coordinate. And so it's got a bunch of stuff about how to decide which agent to hand off to based on the situation. So the key thing behind this is that we've got one, two, three, four different tools here. So what we end up with is the ability to go from one agent with four tools and basically three different sets of system instructions basically describing different situations and what to do to three different agents, each with one to two tools and one system instruction. So we have individual agents have much more focus on their tasks. Now if you think about when we talked about and you've learned about tool naming and having specificity of tools, it makes it easier for an agent to get its job done because its path on what it's allowed to do and how and the rules for it are much narrower and cleaner. And so this is what we get when we start moving to multi-agent systems is we can start having more focused agents that have a smaller set of tools. And typically what we'll see is they will perform better than one giant agent with access to all the tools under the sun and a huge, huge system prompt. We can still have huge system prompts for these that we're going to see is we're going to typically get something that's more predictable, easier to manage, easier to maintain. And if we want to go and make a change to it, it's kind of like a code base that's very modular, right? If we go and make a change to one agent, it's going to be easier to reason about how our changes to its system instructions or tools are going to impact it. It's going to be easier to test it. If we have an agent that has tons of tools and one giant system instruction, it's going to be much harder to reason about how a change to it or a change to its tools is going to affect its overall whole because it's this big morass of complexity. Now, when we start thinking about multi-agent systems, we have to start thinking about communication and how are we going to go and have different agents communicate with each other.